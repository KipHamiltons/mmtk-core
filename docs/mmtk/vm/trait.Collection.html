<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Collection` trait in crate `mmtk`."><meta name="keywords" content="rust, rustlang, rust-lang, Collection"><title>mmtk::vm::Collection - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../mmtk/index.html'><div class='logo-container'><img src='../../rust-logo.png' alt='logo'></div></a><p class='location'>Trait Collection</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#required-methods">Required Methods</a><div class="sidebar-links"><a href="#tymethod.block_for_gc">block_for_gc</a><a href="#tymethod.prepare_mutator">prepare_mutator</a><a href="#tymethod.resume_mutators">resume_mutators</a><a href="#tymethod.spawn_worker_thread">spawn_worker_thread</a><a href="#tymethod.stop_all_mutators">stop_all_mutators</a></div><a class="sidebar-title" href="#provided-methods">Provided Methods</a><div class="sidebar-links"><a href="#method.out_of_memory">out_of_memory</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class='location'><a href='../index.html'>mmtk</a>::<wbr><a href='index.html'>vm</a></p><script>window.sidebarCurrent = {name: 'Collection', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/mmtk/vm/collection.rs.html#8-59' title='goto source code'>[src]</a></span><span class='in-band'>Trait <a href='../index.html'>mmtk</a>::<wbr><a href='index.html'>vm</a>::<wbr><a class="trait" href=''>Collection</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust trait'>pub trait Collection&lt;VM:&nbsp;<a class="trait" href="../../mmtk/vm/trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    fn <a href='#tymethod.stop_all_mutators' class='fnname'>stop_all_mutators</a>&lt;E:&nbsp;<a class="trait" href="../../mmtk/scheduler/gc_works/trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::gc_works::ProcessEdgesWork">ProcessEdgesWork</a>&lt;VM = VM&gt;&gt;(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>);
<div class='item-spacer'></div>    fn <a href='#tymethod.resume_mutators' class='fnname'>resume_mutators</a>(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>);
<div class='item-spacer'></div>    fn <a href='#tymethod.block_for_gc' class='fnname'>block_for_gc</a>(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>);
<div class='item-spacer'></div>    fn <a href='#tymethod.spawn_worker_thread' class='fnname'>spawn_worker_thread</a>(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>, ctx: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="type" href="../../mmtk/scheduler/type.GCWorker.html" title="type mmtk::scheduler::GCWorker">GCWorker</a>&lt;VM&gt;&gt;);
<div class='item-spacer'></div>    fn <a href='#tymethod.prepare_mutator' class='fnname'>prepare_mutator</a>&lt;T:&nbsp;<a class="trait" href="../../mmtk/trait.MutatorContext.html" title="trait mmtk::MutatorContext">MutatorContext</a>&lt;VM&gt;&gt;(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>, m: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T);

    fn <a href='#method.out_of_memory' class='fnname'>out_of_memory</a>(_tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>) { ... }
}</pre></div><div class='docblock'><p>VM-specific methods for garbage collection.</p>
</div>
            <h2 id='required-methods' class='small-section-header'>Required methods<a href='#required-methods' class='anchor'></a></h2><div class='methods'><h3 id='tymethod.stop_all_mutators' class='method'><code>fn <a href='#tymethod.stop_all_mutators' class='fnname'>stop_all_mutators</a>&lt;E:&nbsp;<a class="trait" href="../../mmtk/scheduler/gc_works/trait.ProcessEdgesWork.html" title="trait mmtk::scheduler::gc_works::ProcessEdgesWork">ProcessEdgesWork</a>&lt;VM = VM&gt;&gt;(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>)</code></h3><div class='docblock'><p>Stop all the mutator threads. MMTk calls this method when it requires all the mutator to yield for a GC.
This method is called by a single thread in MMTk (the GC controller).
This method should not return until all the threads are yielded.
The actual thread synchronization mechanism is up to the VM, and MMTk does not make assumptions on that.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC controller/coordinator.</li>
</ul>
</div><h3 id='tymethod.resume_mutators' class='method'><code>fn <a href='#tymethod.resume_mutators' class='fnname'>resume_mutators</a>(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>)</code></h3><div class='docblock'><p>Resume all the mutator threads, the opposite of the above. When a GC is finished, MMTk calls this method.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC controller/coordinator.</li>
</ul>
</div><h3 id='tymethod.block_for_gc' class='method'><code>fn <a href='#tymethod.block_for_gc' class='fnname'>block_for_gc</a>(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>)</code></h3><div class='docblock'><p>Block the current thread for GC. This is called when an allocation request cannot be fulfilled and a GC
is needed. MMTk calls this method to inform the VM that the current thread needs to be blocked as a GC
is going to happen. Then MMTk starts a GC. For a stop-the-world GC, MMTk will then call <code>stop_all_mutators()</code>
before the GC, and call <code>resume_mutators()</code> after the GC.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The current thread pointer that should be blocked. The VM can optionally check if the current thread matches <code>tls</code>.</li>
</ul>
</div><h3 id='tymethod.spawn_worker_thread' class='method'><code>fn <a href='#tymethod.spawn_worker_thread' class='fnname'>spawn_worker_thread</a>(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>, ctx: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="type" href="../../mmtk/scheduler/type.GCWorker.html" title="type mmtk::scheduler::GCWorker">GCWorker</a>&lt;VM&gt;&gt;)</code></h3><div class='docblock'><p>Ask the VM to spawn a GC thread for MMTk. A GC thread may later call into the VM through these VM traits. Some VMs
have assumptions that those calls needs to be within VM internal threads.
As a result, MMTk does not spawn GC threads itself to avoid breaking this kind of assumptions.
MMTk calls this method to spawn GC threads during <a href="../memory_manager/fn.enable_collection.html"><code>enable_collection()</code></a>.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the parent thread that we spawn new threads from. This is the same <code>tls</code> when the VM
calls <code>enable_collection()</code> and passes as an argument.</li>
<li><code>ctx</code>: The GC worker context for the GC thread. If <code>None</code> is passed, it means spawning a GC thread for the GC controller,
which does not have a worker context.</li>
</ul>
</div><h3 id='tymethod.prepare_mutator' class='method'><code>fn <a href='#tymethod.prepare_mutator' class='fnname'>prepare_mutator</a>&lt;T:&nbsp;<a class="trait" href="../../mmtk/trait.MutatorContext.html" title="trait mmtk::MutatorContext">MutatorContext</a>&lt;VM&gt;&gt;(tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>, m: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T)</code></h3><div class='docblock'><p>Allow VM-specific behaviors for a mutator after all the mutators are stopped and before any actual GC work starts.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for a mutator thread.</li>
<li><code>m</code>: The mutator context for the thread.</li>
</ul>
</div></div><span class='loading-content'>Loading content...</span>
            <h2 id='provided-methods' class='small-section-header'>Provided methods<a href='#provided-methods' class='anchor'></a></h2><div class='methods'><h3 id='method.out_of_memory' class='method'><code>fn <a href='#method.out_of_memory' class='fnname'>out_of_memory</a>(_tls: <a class="struct" href="../../mmtk/util/opaque_pointer/struct.OpaquePointer.html" title="struct mmtk::util::opaque_pointer::OpaquePointer">OpaquePointer</a>)</code></h3><div class='docblock'><p>Inform the VM for an out-of-memory error. The VM can implement its own error routine for OOM.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the mutator which failed the allocation and triggered the OOM.</li>
</ul>
</div></div><span class='loading-content'>Loading content...</span>
            <h2 id='implementors' class='small-section-header'>Implementors<a href='#implementors' class='anchor'></a></h2><div class='item-list' id='implementors-list'></div><span class='loading-content'>Loading content...</span><script type="text/javascript" src="../../implementors/mmtk/vm/trait.Collection.js" async></script></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "mmtk";</script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>